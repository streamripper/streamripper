/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "Mockmchar.h"

typedef struct _CMOCK_subnstr_until_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char* ReturnVal;
  char* Expected_str;
  char* Expected_until;
  char* Expected_newstr;
  int Expected_maxlen;

} CMOCK_subnstr_until_CALL_INSTANCE;

typedef struct _CMOCK_left_str_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char* ReturnVal;
  char* Expected_str;
  int Expected_len;

} CMOCK_left_str_CALL_INSTANCE;

typedef struct _CMOCK_format_byte_size_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char* ReturnVal;
  char* Expected_str;
  long Expected_size;

} CMOCK_format_byte_size_CALL_INSTANCE;

typedef struct _CMOCK_trim_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char* Expected_str;

} CMOCK_trim_CALL_INSTANCE;

typedef struct _CMOCK_sr_strncpy_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char* Expected_dst;
  char* Expected_src;
  int Expected_n;

} CMOCK_sr_strncpy_CALL_INSTANCE;

typedef struct _CMOCK_sr_set_locale_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_sr_set_locale_CALL_INSTANCE;

typedef struct _CMOCK_set_codesets_default_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  CODESET_OPTIONS* Expected_cs_opt;

} CMOCK_set_codesets_default_CALL_INSTANCE;

typedef struct _CMOCK_register_codesets_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RIP_MANAGER_INFO* Expected_rmi;
  CODESET_OPTIONS* Expected_cs_opt;

} CMOCK_register_codesets_CALL_INSTANCE;

typedef struct _CMOCK_gstring_from_string_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  RIP_MANAGER_INFO* Expected_rmi;
  mchar* Expected_m;
  int Expected_mlen;
  char* Expected_c;
  int Expected_codeset_type;

} CMOCK_gstring_from_string_CALL_INSTANCE;

typedef struct _CMOCK_string_from_gstring_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  RIP_MANAGER_INFO* Expected_rmi;
  char* Expected_c;
  int Expected_clen;
  mchar* Expected_m;
  int Expected_codeset_type;

} CMOCK_string_from_gstring_CALL_INSTANCE;

typedef struct _CMOCK_mstrdup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  mchar* ReturnVal;
  mchar* Expected_src;

} CMOCK_mstrdup_CALL_INSTANCE;

typedef struct _CMOCK_mstrcpy_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  mchar* ReturnVal;
  mchar* Expected_dest;
  mchar* Expected_src;

} CMOCK_mstrcpy_CALL_INSTANCE;

typedef struct _CMOCK_msnprintf_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  mchar* Expected_dest;
  size_t Expected_n;
  mchar* Expected_fmt;

} CMOCK_msnprintf_CALL_INSTANCE;

typedef struct _CMOCK_mstrncpy_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  mchar* Expected_dst;
  mchar* Expected_src;
  int Expected_n;

} CMOCK_mstrncpy_CALL_INSTANCE;

typedef struct _CMOCK_mstrlen_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  size_t ReturnVal;
  mchar* Expected_s;

} CMOCK_mstrlen_CALL_INSTANCE;

typedef struct _CMOCK_mstrchr_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  mchar* ReturnVal;
  mchar* Expected_ws;
  mchar Expected_wc;

} CMOCK_mstrchr_CALL_INSTANCE;

typedef struct _CMOCK_mstrrchr_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  mchar* ReturnVal;
  mchar* Expected_ws;
  mchar Expected_wc;

} CMOCK_mstrrchr_CALL_INSTANCE;

typedef struct _CMOCK_mstrncat_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  mchar* ReturnVal;
  mchar* Expected_ws1;
  mchar* Expected_ws2;
  size_t Expected_n;

} CMOCK_mstrncat_CALL_INSTANCE;

typedef struct _CMOCK_mstrcmp_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  mchar* Expected_ws1;
  mchar* Expected_ws2;

} CMOCK_mstrcmp_CALL_INSTANCE;

typedef struct _CMOCK_mtol_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  long int ReturnVal;
  mchar* Expected_string;

} CMOCK_mtol_CALL_INSTANCE;

typedef struct _CMOCK_is_id3_unicode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  RIP_MANAGER_INFO* Expected_mchar_cs;

} CMOCK_is_id3_unicode_CALL_INSTANCE;

typedef struct _CMOCK_utf8_string_from_string_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  gchar* ReturnVal;
  char* Expected_src;
  char* Expected_codeset;

} CMOCK_utf8_string_from_string_CALL_INSTANCE;

static struct MockmcharInstance
{
  int subnstr_until_IgnoreBool;
  char* subnstr_until_FinalReturn;
  CMOCK_subnstr_until_CALLBACK subnstr_until_CallbackFunctionPointer;
  int subnstr_until_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE subnstr_until_CallInstance;
  int left_str_IgnoreBool;
  char* left_str_FinalReturn;
  CMOCK_left_str_CALLBACK left_str_CallbackFunctionPointer;
  int left_str_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE left_str_CallInstance;
  int format_byte_size_IgnoreBool;
  char* format_byte_size_FinalReturn;
  CMOCK_format_byte_size_CALLBACK format_byte_size_CallbackFunctionPointer;
  int format_byte_size_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE format_byte_size_CallInstance;
  int trim_IgnoreBool;
  CMOCK_trim_CALLBACK trim_CallbackFunctionPointer;
  int trim_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE trim_CallInstance;
  int sr_strncpy_IgnoreBool;
  CMOCK_sr_strncpy_CALLBACK sr_strncpy_CallbackFunctionPointer;
  int sr_strncpy_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE sr_strncpy_CallInstance;
  int sr_set_locale_IgnoreBool;
  CMOCK_sr_set_locale_CALLBACK sr_set_locale_CallbackFunctionPointer;
  int sr_set_locale_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE sr_set_locale_CallInstance;
  int set_codesets_default_IgnoreBool;
  CMOCK_set_codesets_default_CALLBACK set_codesets_default_CallbackFunctionPointer;
  int set_codesets_default_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE set_codesets_default_CallInstance;
  int register_codesets_IgnoreBool;
  CMOCK_register_codesets_CALLBACK register_codesets_CallbackFunctionPointer;
  int register_codesets_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE register_codesets_CallInstance;
  int gstring_from_string_IgnoreBool;
  int gstring_from_string_FinalReturn;
  CMOCK_gstring_from_string_CALLBACK gstring_from_string_CallbackFunctionPointer;
  int gstring_from_string_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gstring_from_string_CallInstance;
  int string_from_gstring_IgnoreBool;
  int string_from_gstring_FinalReturn;
  CMOCK_string_from_gstring_CALLBACK string_from_gstring_CallbackFunctionPointer;
  int string_from_gstring_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE string_from_gstring_CallInstance;
  int mstrdup_IgnoreBool;
  mchar* mstrdup_FinalReturn;
  CMOCK_mstrdup_CALLBACK mstrdup_CallbackFunctionPointer;
  int mstrdup_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE mstrdup_CallInstance;
  int mstrcpy_IgnoreBool;
  mchar* mstrcpy_FinalReturn;
  CMOCK_mstrcpy_CALLBACK mstrcpy_CallbackFunctionPointer;
  int mstrcpy_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE mstrcpy_CallInstance;
  int msnprintf_IgnoreBool;
  int msnprintf_FinalReturn;
  CMOCK_msnprintf_CALLBACK msnprintf_CallbackFunctionPointer;
  int msnprintf_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE msnprintf_CallInstance;
  int mstrncpy_IgnoreBool;
  CMOCK_mstrncpy_CALLBACK mstrncpy_CallbackFunctionPointer;
  int mstrncpy_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE mstrncpy_CallInstance;
  int mstrlen_IgnoreBool;
  size_t mstrlen_FinalReturn;
  CMOCK_mstrlen_CALLBACK mstrlen_CallbackFunctionPointer;
  int mstrlen_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE mstrlen_CallInstance;
  int mstrchr_IgnoreBool;
  mchar* mstrchr_FinalReturn;
  CMOCK_mstrchr_CALLBACK mstrchr_CallbackFunctionPointer;
  int mstrchr_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE mstrchr_CallInstance;
  int mstrrchr_IgnoreBool;
  mchar* mstrrchr_FinalReturn;
  CMOCK_mstrrchr_CALLBACK mstrrchr_CallbackFunctionPointer;
  int mstrrchr_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE mstrrchr_CallInstance;
  int mstrncat_IgnoreBool;
  mchar* mstrncat_FinalReturn;
  CMOCK_mstrncat_CALLBACK mstrncat_CallbackFunctionPointer;
  int mstrncat_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE mstrncat_CallInstance;
  int mstrcmp_IgnoreBool;
  int mstrcmp_FinalReturn;
  CMOCK_mstrcmp_CALLBACK mstrcmp_CallbackFunctionPointer;
  int mstrcmp_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE mstrcmp_CallInstance;
  int mtol_IgnoreBool;
  long int mtol_FinalReturn;
  CMOCK_mtol_CALLBACK mtol_CallbackFunctionPointer;
  int mtol_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE mtol_CallInstance;
  int is_id3_unicode_IgnoreBool;
  int is_id3_unicode_FinalReturn;
  CMOCK_is_id3_unicode_CALLBACK is_id3_unicode_CallbackFunctionPointer;
  int is_id3_unicode_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE is_id3_unicode_CallInstance;
  int utf8_string_from_string_IgnoreBool;
  gchar* utf8_string_from_string_FinalReturn;
  CMOCK_utf8_string_from_string_CALLBACK utf8_string_from_string_CallbackFunctionPointer;
  int utf8_string_from_string_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE utf8_string_from_string_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockmchar_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.subnstr_until_IgnoreBool)
    Mock.subnstr_until_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.subnstr_until_CallInstance, cmock_line, "Function 'subnstr_until' called less times than expected.");
  if (Mock.subnstr_until_CallbackFunctionPointer != NULL)
    Mock.subnstr_until_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.left_str_IgnoreBool)
    Mock.left_str_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.left_str_CallInstance, cmock_line, "Function 'left_str' called less times than expected.");
  if (Mock.left_str_CallbackFunctionPointer != NULL)
    Mock.left_str_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.format_byte_size_IgnoreBool)
    Mock.format_byte_size_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.format_byte_size_CallInstance, cmock_line, "Function 'format_byte_size' called less times than expected.");
  if (Mock.format_byte_size_CallbackFunctionPointer != NULL)
    Mock.format_byte_size_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.trim_IgnoreBool)
    Mock.trim_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.trim_CallInstance, cmock_line, "Function 'trim' called less times than expected.");
  if (Mock.trim_CallbackFunctionPointer != NULL)
    Mock.trim_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.sr_strncpy_IgnoreBool)
    Mock.sr_strncpy_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sr_strncpy_CallInstance, cmock_line, "Function 'sr_strncpy' called less times than expected.");
  if (Mock.sr_strncpy_CallbackFunctionPointer != NULL)
    Mock.sr_strncpy_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.sr_set_locale_IgnoreBool)
    Mock.sr_set_locale_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sr_set_locale_CallInstance, cmock_line, "Function 'sr_set_locale' called less times than expected.");
  if (Mock.sr_set_locale_CallbackFunctionPointer != NULL)
    Mock.sr_set_locale_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.set_codesets_default_IgnoreBool)
    Mock.set_codesets_default_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.set_codesets_default_CallInstance, cmock_line, "Function 'set_codesets_default' called less times than expected.");
  if (Mock.set_codesets_default_CallbackFunctionPointer != NULL)
    Mock.set_codesets_default_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.register_codesets_IgnoreBool)
    Mock.register_codesets_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.register_codesets_CallInstance, cmock_line, "Function 'register_codesets' called less times than expected.");
  if (Mock.register_codesets_CallbackFunctionPointer != NULL)
    Mock.register_codesets_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.gstring_from_string_IgnoreBool)
    Mock.gstring_from_string_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.gstring_from_string_CallInstance, cmock_line, "Function 'gstring_from_string' called less times than expected.");
  if (Mock.gstring_from_string_CallbackFunctionPointer != NULL)
    Mock.gstring_from_string_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.string_from_gstring_IgnoreBool)
    Mock.string_from_gstring_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.string_from_gstring_CallInstance, cmock_line, "Function 'string_from_gstring' called less times than expected.");
  if (Mock.string_from_gstring_CallbackFunctionPointer != NULL)
    Mock.string_from_gstring_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.mstrdup_IgnoreBool)
    Mock.mstrdup_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.mstrdup_CallInstance, cmock_line, "Function 'mstrdup' called less times than expected.");
  if (Mock.mstrdup_CallbackFunctionPointer != NULL)
    Mock.mstrdup_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.mstrcpy_IgnoreBool)
    Mock.mstrcpy_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.mstrcpy_CallInstance, cmock_line, "Function 'mstrcpy' called less times than expected.");
  if (Mock.mstrcpy_CallbackFunctionPointer != NULL)
    Mock.mstrcpy_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.msnprintf_IgnoreBool)
    Mock.msnprintf_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.msnprintf_CallInstance, cmock_line, "Function 'msnprintf' called less times than expected.");
  if (Mock.msnprintf_CallbackFunctionPointer != NULL)
    Mock.msnprintf_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.mstrncpy_IgnoreBool)
    Mock.mstrncpy_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.mstrncpy_CallInstance, cmock_line, "Function 'mstrncpy' called less times than expected.");
  if (Mock.mstrncpy_CallbackFunctionPointer != NULL)
    Mock.mstrncpy_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.mstrlen_IgnoreBool)
    Mock.mstrlen_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.mstrlen_CallInstance, cmock_line, "Function 'mstrlen' called less times than expected.");
  if (Mock.mstrlen_CallbackFunctionPointer != NULL)
    Mock.mstrlen_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.mstrchr_IgnoreBool)
    Mock.mstrchr_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.mstrchr_CallInstance, cmock_line, "Function 'mstrchr' called less times than expected.");
  if (Mock.mstrchr_CallbackFunctionPointer != NULL)
    Mock.mstrchr_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.mstrrchr_IgnoreBool)
    Mock.mstrrchr_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.mstrrchr_CallInstance, cmock_line, "Function 'mstrrchr' called less times than expected.");
  if (Mock.mstrrchr_CallbackFunctionPointer != NULL)
    Mock.mstrrchr_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.mstrncat_IgnoreBool)
    Mock.mstrncat_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.mstrncat_CallInstance, cmock_line, "Function 'mstrncat' called less times than expected.");
  if (Mock.mstrncat_CallbackFunctionPointer != NULL)
    Mock.mstrncat_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.mstrcmp_IgnoreBool)
    Mock.mstrcmp_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.mstrcmp_CallInstance, cmock_line, "Function 'mstrcmp' called less times than expected.");
  if (Mock.mstrcmp_CallbackFunctionPointer != NULL)
    Mock.mstrcmp_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.mtol_IgnoreBool)
    Mock.mtol_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.mtol_CallInstance, cmock_line, "Function 'mtol' called less times than expected.");
  if (Mock.mtol_CallbackFunctionPointer != NULL)
    Mock.mtol_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.is_id3_unicode_IgnoreBool)
    Mock.is_id3_unicode_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.is_id3_unicode_CallInstance, cmock_line, "Function 'is_id3_unicode' called less times than expected.");
  if (Mock.is_id3_unicode_CallbackFunctionPointer != NULL)
    Mock.is_id3_unicode_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.utf8_string_from_string_IgnoreBool)
    Mock.utf8_string_from_string_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.utf8_string_from_string_CallInstance, cmock_line, "Function 'utf8_string_from_string' called less times than expected.");
  if (Mock.utf8_string_from_string_CallbackFunctionPointer != NULL)
    Mock.utf8_string_from_string_CallInstance = CMOCK_GUTS_NONE;
}

void Mockmchar_Init(void)
{
  Mockmchar_Destroy();
}

void Mockmchar_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.subnstr_until_CallbackFunctionPointer = NULL;
  Mock.subnstr_until_CallbackCalls = 0;
  Mock.left_str_CallbackFunctionPointer = NULL;
  Mock.left_str_CallbackCalls = 0;
  Mock.format_byte_size_CallbackFunctionPointer = NULL;
  Mock.format_byte_size_CallbackCalls = 0;
  Mock.trim_CallbackFunctionPointer = NULL;
  Mock.trim_CallbackCalls = 0;
  Mock.sr_strncpy_CallbackFunctionPointer = NULL;
  Mock.sr_strncpy_CallbackCalls = 0;
  Mock.sr_set_locale_CallbackFunctionPointer = NULL;
  Mock.sr_set_locale_CallbackCalls = 0;
  Mock.set_codesets_default_CallbackFunctionPointer = NULL;
  Mock.set_codesets_default_CallbackCalls = 0;
  Mock.register_codesets_CallbackFunctionPointer = NULL;
  Mock.register_codesets_CallbackCalls = 0;
  Mock.gstring_from_string_CallbackFunctionPointer = NULL;
  Mock.gstring_from_string_CallbackCalls = 0;
  Mock.string_from_gstring_CallbackFunctionPointer = NULL;
  Mock.string_from_gstring_CallbackCalls = 0;
  Mock.mstrdup_CallbackFunctionPointer = NULL;
  Mock.mstrdup_CallbackCalls = 0;
  Mock.mstrcpy_CallbackFunctionPointer = NULL;
  Mock.mstrcpy_CallbackCalls = 0;
  Mock.msnprintf_CallbackFunctionPointer = NULL;
  Mock.msnprintf_CallbackCalls = 0;
  Mock.mstrncpy_CallbackFunctionPointer = NULL;
  Mock.mstrncpy_CallbackCalls = 0;
  Mock.mstrlen_CallbackFunctionPointer = NULL;
  Mock.mstrlen_CallbackCalls = 0;
  Mock.mstrchr_CallbackFunctionPointer = NULL;
  Mock.mstrchr_CallbackCalls = 0;
  Mock.mstrrchr_CallbackFunctionPointer = NULL;
  Mock.mstrrchr_CallbackCalls = 0;
  Mock.mstrncat_CallbackFunctionPointer = NULL;
  Mock.mstrncat_CallbackCalls = 0;
  Mock.mstrcmp_CallbackFunctionPointer = NULL;
  Mock.mstrcmp_CallbackCalls = 0;
  Mock.mtol_CallbackFunctionPointer = NULL;
  Mock.mtol_CallbackCalls = 0;
  Mock.is_id3_unicode_CallbackFunctionPointer = NULL;
  Mock.is_id3_unicode_CallbackCalls = 0;
  Mock.utf8_string_from_string_CallbackFunctionPointer = NULL;
  Mock.utf8_string_from_string_CallbackCalls = 0;
}

char* subnstr_until(const char* str, char* until, char* newstr, int maxlen)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_subnstr_until_CALL_INSTANCE* cmock_call_instance = (CMOCK_subnstr_until_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.subnstr_until_CallInstance);
  Mock.subnstr_until_CallInstance = CMock_Guts_MemNext(Mock.subnstr_until_CallInstance);
  if (Mock.subnstr_until_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.subnstr_until_FinalReturn;
    Mock.subnstr_until_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.subnstr_until_CallbackFunctionPointer != NULL)
  {
    return Mock.subnstr_until_CallbackFunctionPointer(str, until, newstr, maxlen, Mock.subnstr_until_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'subnstr_until' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_str, str, cmock_line, "Function 'subnstr_until' called with unexpected value for argument 'str'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_until, until, cmock_line, "Function 'subnstr_until' called with unexpected value for argument 'until'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_newstr, newstr, cmock_line, "Function 'subnstr_until' called with unexpected value for argument 'newstr'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_maxlen, maxlen, cmock_line, "Function 'subnstr_until' called with unexpected value for argument 'maxlen'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_subnstr_until(CMOCK_subnstr_until_CALL_INSTANCE* cmock_call_instance, const char* str, char* until, char* newstr, int maxlen)
{
  cmock_call_instance->Expected_str = (char*)str;
  cmock_call_instance->Expected_until = until;
  cmock_call_instance->Expected_newstr = newstr;
  cmock_call_instance->Expected_maxlen = maxlen;
}

void subnstr_until_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_subnstr_until_CALL_INSTANCE));
  CMOCK_subnstr_until_CALL_INSTANCE* cmock_call_instance = (CMOCK_subnstr_until_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.subnstr_until_CallInstance = CMock_Guts_MemChain(Mock.subnstr_until_CallInstance, cmock_guts_index);
  Mock.subnstr_until_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.subnstr_until_IgnoreBool = (int)1;
}

void subnstr_until_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* str, char* until, char* newstr, int maxlen, char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_subnstr_until_CALL_INSTANCE));
  CMOCK_subnstr_until_CALL_INSTANCE* cmock_call_instance = (CMOCK_subnstr_until_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.subnstr_until_CallInstance = CMock_Guts_MemChain(Mock.subnstr_until_CallInstance, cmock_guts_index);
  Mock.subnstr_until_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_subnstr_until(cmock_call_instance, str, until, newstr, maxlen);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void subnstr_until_StubWithCallback(CMOCK_subnstr_until_CALLBACK Callback)
{
  Mock.subnstr_until_CallbackFunctionPointer = Callback;
}

char* left_str(char* str, int len)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_left_str_CALL_INSTANCE* cmock_call_instance = (CMOCK_left_str_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.left_str_CallInstance);
  Mock.left_str_CallInstance = CMock_Guts_MemNext(Mock.left_str_CallInstance);
  if (Mock.left_str_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.left_str_FinalReturn;
    Mock.left_str_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.left_str_CallbackFunctionPointer != NULL)
  {
    return Mock.left_str_CallbackFunctionPointer(str, len, Mock.left_str_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'left_str' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_str, str, cmock_line, "Function 'left_str' called with unexpected value for argument 'str'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_len, len, cmock_line, "Function 'left_str' called with unexpected value for argument 'len'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_left_str(CMOCK_left_str_CALL_INSTANCE* cmock_call_instance, char* str, int len)
{
  cmock_call_instance->Expected_str = str;
  cmock_call_instance->Expected_len = len;
}

void left_str_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_left_str_CALL_INSTANCE));
  CMOCK_left_str_CALL_INSTANCE* cmock_call_instance = (CMOCK_left_str_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.left_str_CallInstance = CMock_Guts_MemChain(Mock.left_str_CallInstance, cmock_guts_index);
  Mock.left_str_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.left_str_IgnoreBool = (int)1;
}

void left_str_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* str, int len, char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_left_str_CALL_INSTANCE));
  CMOCK_left_str_CALL_INSTANCE* cmock_call_instance = (CMOCK_left_str_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.left_str_CallInstance = CMock_Guts_MemChain(Mock.left_str_CallInstance, cmock_guts_index);
  Mock.left_str_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_left_str(cmock_call_instance, str, len);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void left_str_StubWithCallback(CMOCK_left_str_CALLBACK Callback)
{
  Mock.left_str_CallbackFunctionPointer = Callback;
}

char* format_byte_size(char* str, long size)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_format_byte_size_CALL_INSTANCE* cmock_call_instance = (CMOCK_format_byte_size_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.format_byte_size_CallInstance);
  Mock.format_byte_size_CallInstance = CMock_Guts_MemNext(Mock.format_byte_size_CallInstance);
  if (Mock.format_byte_size_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.format_byte_size_FinalReturn;
    Mock.format_byte_size_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.format_byte_size_CallbackFunctionPointer != NULL)
  {
    return Mock.format_byte_size_CallbackFunctionPointer(str, size, Mock.format_byte_size_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'format_byte_size' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_str, str, cmock_line, "Function 'format_byte_size' called with unexpected value for argument 'str'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_size, size, cmock_line, "Function 'format_byte_size' called with unexpected value for argument 'size'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_format_byte_size(CMOCK_format_byte_size_CALL_INSTANCE* cmock_call_instance, char* str, long size)
{
  cmock_call_instance->Expected_str = str;
  cmock_call_instance->Expected_size = size;
}

void format_byte_size_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_format_byte_size_CALL_INSTANCE));
  CMOCK_format_byte_size_CALL_INSTANCE* cmock_call_instance = (CMOCK_format_byte_size_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.format_byte_size_CallInstance = CMock_Guts_MemChain(Mock.format_byte_size_CallInstance, cmock_guts_index);
  Mock.format_byte_size_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.format_byte_size_IgnoreBool = (int)1;
}

void format_byte_size_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* str, long size, char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_format_byte_size_CALL_INSTANCE));
  CMOCK_format_byte_size_CALL_INSTANCE* cmock_call_instance = (CMOCK_format_byte_size_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.format_byte_size_CallInstance = CMock_Guts_MemChain(Mock.format_byte_size_CallInstance, cmock_guts_index);
  Mock.format_byte_size_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_format_byte_size(cmock_call_instance, str, size);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void format_byte_size_StubWithCallback(CMOCK_format_byte_size_CALLBACK Callback)
{
  Mock.format_byte_size_CallbackFunctionPointer = Callback;
}

void trim(char* str)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_trim_CALL_INSTANCE* cmock_call_instance = (CMOCK_trim_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.trim_CallInstance);
  Mock.trim_CallInstance = CMock_Guts_MemNext(Mock.trim_CallInstance);
  if (Mock.trim_IgnoreBool)
  {
    return;
  }
  if (Mock.trim_CallbackFunctionPointer != NULL)
  {
    Mock.trim_CallbackFunctionPointer(str, Mock.trim_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'trim' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_str, str, cmock_line, "Function 'trim' called with unexpected value for argument 'str'.");
  }
}

void CMockExpectParameters_trim(CMOCK_trim_CALL_INSTANCE* cmock_call_instance, char* str)
{
  cmock_call_instance->Expected_str = str;
}

void trim_CMockIgnore(void)
{
  Mock.trim_IgnoreBool = (int)1;
}

void trim_CMockExpect(UNITY_LINE_TYPE cmock_line, char* str)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_trim_CALL_INSTANCE));
  CMOCK_trim_CALL_INSTANCE* cmock_call_instance = (CMOCK_trim_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.trim_CallInstance = CMock_Guts_MemChain(Mock.trim_CallInstance, cmock_guts_index);
  Mock.trim_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_trim(cmock_call_instance, str);
}

void trim_StubWithCallback(CMOCK_trim_CALLBACK Callback)
{
  Mock.trim_CallbackFunctionPointer = Callback;
}

void sr_strncpy(char* dst, char* src, int n)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_sr_strncpy_CALL_INSTANCE* cmock_call_instance = (CMOCK_sr_strncpy_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sr_strncpy_CallInstance);
  Mock.sr_strncpy_CallInstance = CMock_Guts_MemNext(Mock.sr_strncpy_CallInstance);
  if (Mock.sr_strncpy_IgnoreBool)
  {
    return;
  }
  if (Mock.sr_strncpy_CallbackFunctionPointer != NULL)
  {
    Mock.sr_strncpy_CallbackFunctionPointer(dst, src, n, Mock.sr_strncpy_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sr_strncpy' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_dst, dst, cmock_line, "Function 'sr_strncpy' called with unexpected value for argument 'dst'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_src, src, cmock_line, "Function 'sr_strncpy' called with unexpected value for argument 'src'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_n, n, cmock_line, "Function 'sr_strncpy' called with unexpected value for argument 'n'.");
  }
}

void CMockExpectParameters_sr_strncpy(CMOCK_sr_strncpy_CALL_INSTANCE* cmock_call_instance, char* dst, char* src, int n)
{
  cmock_call_instance->Expected_dst = dst;
  cmock_call_instance->Expected_src = src;
  cmock_call_instance->Expected_n = n;
}

void sr_strncpy_CMockIgnore(void)
{
  Mock.sr_strncpy_IgnoreBool = (int)1;
}

void sr_strncpy_CMockExpect(UNITY_LINE_TYPE cmock_line, char* dst, char* src, int n)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sr_strncpy_CALL_INSTANCE));
  CMOCK_sr_strncpy_CALL_INSTANCE* cmock_call_instance = (CMOCK_sr_strncpy_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.sr_strncpy_CallInstance = CMock_Guts_MemChain(Mock.sr_strncpy_CallInstance, cmock_guts_index);
  Mock.sr_strncpy_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_sr_strncpy(cmock_call_instance, dst, src, n);
}

void sr_strncpy_StubWithCallback(CMOCK_sr_strncpy_CALLBACK Callback)
{
  Mock.sr_strncpy_CallbackFunctionPointer = Callback;
}

void sr_set_locale(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_sr_set_locale_CALL_INSTANCE* cmock_call_instance = (CMOCK_sr_set_locale_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sr_set_locale_CallInstance);
  Mock.sr_set_locale_CallInstance = CMock_Guts_MemNext(Mock.sr_set_locale_CallInstance);
  if (Mock.sr_set_locale_IgnoreBool)
  {
    return;
  }
  if (Mock.sr_set_locale_CallbackFunctionPointer != NULL)
  {
    Mock.sr_set_locale_CallbackFunctionPointer(Mock.sr_set_locale_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sr_set_locale' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
}

void sr_set_locale_CMockIgnore(void)
{
  Mock.sr_set_locale_IgnoreBool = (int)1;
}

void sr_set_locale_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sr_set_locale_CALL_INSTANCE));
  CMOCK_sr_set_locale_CALL_INSTANCE* cmock_call_instance = (CMOCK_sr_set_locale_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.sr_set_locale_CallInstance = CMock_Guts_MemChain(Mock.sr_set_locale_CallInstance, cmock_guts_index);
  Mock.sr_set_locale_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
}

void sr_set_locale_StubWithCallback(CMOCK_sr_set_locale_CALLBACK Callback)
{
  Mock.sr_set_locale_CallbackFunctionPointer = Callback;
}

void set_codesets_default(CODESET_OPTIONS* cs_opt)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_set_codesets_default_CALL_INSTANCE* cmock_call_instance = (CMOCK_set_codesets_default_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.set_codesets_default_CallInstance);
  Mock.set_codesets_default_CallInstance = CMock_Guts_MemNext(Mock.set_codesets_default_CallInstance);
  if (Mock.set_codesets_default_IgnoreBool)
  {
    return;
  }
  if (Mock.set_codesets_default_CallbackFunctionPointer != NULL)
  {
    Mock.set_codesets_default_CallbackFunctionPointer(cs_opt, Mock.set_codesets_default_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'set_codesets_default' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_cs_opt), (void*)(cs_opt), sizeof(CODESET_OPTIONS), cmock_line, "Function 'set_codesets_default' called with unexpected value for argument 'cs_opt'.");
  }
}

void CMockExpectParameters_set_codesets_default(CMOCK_set_codesets_default_CALL_INSTANCE* cmock_call_instance, CODESET_OPTIONS* cs_opt)
{
  cmock_call_instance->Expected_cs_opt = cs_opt;
}

void set_codesets_default_CMockIgnore(void)
{
  Mock.set_codesets_default_IgnoreBool = (int)1;
}

void set_codesets_default_CMockExpect(UNITY_LINE_TYPE cmock_line, CODESET_OPTIONS* cs_opt)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_set_codesets_default_CALL_INSTANCE));
  CMOCK_set_codesets_default_CALL_INSTANCE* cmock_call_instance = (CMOCK_set_codesets_default_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.set_codesets_default_CallInstance = CMock_Guts_MemChain(Mock.set_codesets_default_CallInstance, cmock_guts_index);
  Mock.set_codesets_default_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_set_codesets_default(cmock_call_instance, cs_opt);
}

void set_codesets_default_StubWithCallback(CMOCK_set_codesets_default_CALLBACK Callback)
{
  Mock.set_codesets_default_CallbackFunctionPointer = Callback;
}

void register_codesets(RIP_MANAGER_INFO* rmi, CODESET_OPTIONS* cs_opt)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_register_codesets_CALL_INSTANCE* cmock_call_instance = (CMOCK_register_codesets_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.register_codesets_CallInstance);
  Mock.register_codesets_CallInstance = CMock_Guts_MemNext(Mock.register_codesets_CallInstance);
  if (Mock.register_codesets_IgnoreBool)
  {
    return;
  }
  if (Mock.register_codesets_CallbackFunctionPointer != NULL)
  {
    Mock.register_codesets_CallbackFunctionPointer(rmi, cs_opt, Mock.register_codesets_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'register_codesets' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_rmi), (void*)(rmi), sizeof(RIP_MANAGER_INFO), cmock_line, "Function 'register_codesets' called with unexpected value for argument 'rmi'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_cs_opt), (void*)(cs_opt), sizeof(CODESET_OPTIONS), cmock_line, "Function 'register_codesets' called with unexpected value for argument 'cs_opt'.");
  }
}

void CMockExpectParameters_register_codesets(CMOCK_register_codesets_CALL_INSTANCE* cmock_call_instance, RIP_MANAGER_INFO* rmi, CODESET_OPTIONS* cs_opt)
{
  cmock_call_instance->Expected_rmi = rmi;
  cmock_call_instance->Expected_cs_opt = cs_opt;
}

void register_codesets_CMockIgnore(void)
{
  Mock.register_codesets_IgnoreBool = (int)1;
}

void register_codesets_CMockExpect(UNITY_LINE_TYPE cmock_line, RIP_MANAGER_INFO* rmi, CODESET_OPTIONS* cs_opt)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_register_codesets_CALL_INSTANCE));
  CMOCK_register_codesets_CALL_INSTANCE* cmock_call_instance = (CMOCK_register_codesets_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.register_codesets_CallInstance = CMock_Guts_MemChain(Mock.register_codesets_CallInstance, cmock_guts_index);
  Mock.register_codesets_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_register_codesets(cmock_call_instance, rmi, cs_opt);
}

void register_codesets_StubWithCallback(CMOCK_register_codesets_CALLBACK Callback)
{
  Mock.register_codesets_CallbackFunctionPointer = Callback;
}

int gstring_from_string(RIP_MANAGER_INFO* rmi, mchar* m, int mlen, char* c, int codeset_type)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gstring_from_string_CALL_INSTANCE* cmock_call_instance = (CMOCK_gstring_from_string_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gstring_from_string_CallInstance);
  Mock.gstring_from_string_CallInstance = CMock_Guts_MemNext(Mock.gstring_from_string_CallInstance);
  if (Mock.gstring_from_string_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.gstring_from_string_FinalReturn;
    Mock.gstring_from_string_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.gstring_from_string_CallbackFunctionPointer != NULL)
  {
    return Mock.gstring_from_string_CallbackFunctionPointer(rmi, m, mlen, c, codeset_type, Mock.gstring_from_string_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'gstring_from_string' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_rmi), (void*)(rmi), sizeof(RIP_MANAGER_INFO), cmock_line, "Function 'gstring_from_string' called with unexpected value for argument 'rmi'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_m), (void*)(m), sizeof(mchar), cmock_line, "Function 'gstring_from_string' called with unexpected value for argument 'm'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_mlen, mlen, cmock_line, "Function 'gstring_from_string' called with unexpected value for argument 'mlen'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_c, c, cmock_line, "Function 'gstring_from_string' called with unexpected value for argument 'c'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_codeset_type, codeset_type, cmock_line, "Function 'gstring_from_string' called with unexpected value for argument 'codeset_type'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gstring_from_string(CMOCK_gstring_from_string_CALL_INSTANCE* cmock_call_instance, RIP_MANAGER_INFO* rmi, mchar* m, int mlen, char* c, int codeset_type)
{
  cmock_call_instance->Expected_rmi = rmi;
  cmock_call_instance->Expected_m = m;
  cmock_call_instance->Expected_mlen = mlen;
  cmock_call_instance->Expected_c = c;
  cmock_call_instance->Expected_codeset_type = codeset_type;
}

void gstring_from_string_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gstring_from_string_CALL_INSTANCE));
  CMOCK_gstring_from_string_CALL_INSTANCE* cmock_call_instance = (CMOCK_gstring_from_string_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gstring_from_string_CallInstance = CMock_Guts_MemChain(Mock.gstring_from_string_CallInstance, cmock_guts_index);
  Mock.gstring_from_string_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gstring_from_string_IgnoreBool = (int)1;
}

void gstring_from_string_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, RIP_MANAGER_INFO* rmi, mchar* m, int mlen, char* c, int codeset_type, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gstring_from_string_CALL_INSTANCE));
  CMOCK_gstring_from_string_CALL_INSTANCE* cmock_call_instance = (CMOCK_gstring_from_string_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gstring_from_string_CallInstance = CMock_Guts_MemChain(Mock.gstring_from_string_CallInstance, cmock_guts_index);
  Mock.gstring_from_string_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_gstring_from_string(cmock_call_instance, rmi, m, mlen, c, codeset_type);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void gstring_from_string_StubWithCallback(CMOCK_gstring_from_string_CALLBACK Callback)
{
  Mock.gstring_from_string_CallbackFunctionPointer = Callback;
}

int string_from_gstring(RIP_MANAGER_INFO* rmi, char* c, int clen, mchar* m, int codeset_type)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_string_from_gstring_CALL_INSTANCE* cmock_call_instance = (CMOCK_string_from_gstring_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.string_from_gstring_CallInstance);
  Mock.string_from_gstring_CallInstance = CMock_Guts_MemNext(Mock.string_from_gstring_CallInstance);
  if (Mock.string_from_gstring_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.string_from_gstring_FinalReturn;
    Mock.string_from_gstring_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.string_from_gstring_CallbackFunctionPointer != NULL)
  {
    return Mock.string_from_gstring_CallbackFunctionPointer(rmi, c, clen, m, codeset_type, Mock.string_from_gstring_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'string_from_gstring' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_rmi), (void*)(rmi), sizeof(RIP_MANAGER_INFO), cmock_line, "Function 'string_from_gstring' called with unexpected value for argument 'rmi'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_c, c, cmock_line, "Function 'string_from_gstring' called with unexpected value for argument 'c'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_clen, clen, cmock_line, "Function 'string_from_gstring' called with unexpected value for argument 'clen'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_m), (void*)(m), sizeof(mchar), cmock_line, "Function 'string_from_gstring' called with unexpected value for argument 'm'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_codeset_type, codeset_type, cmock_line, "Function 'string_from_gstring' called with unexpected value for argument 'codeset_type'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_string_from_gstring(CMOCK_string_from_gstring_CALL_INSTANCE* cmock_call_instance, RIP_MANAGER_INFO* rmi, char* c, int clen, mchar* m, int codeset_type)
{
  cmock_call_instance->Expected_rmi = rmi;
  cmock_call_instance->Expected_c = c;
  cmock_call_instance->Expected_clen = clen;
  cmock_call_instance->Expected_m = m;
  cmock_call_instance->Expected_codeset_type = codeset_type;
}

void string_from_gstring_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_string_from_gstring_CALL_INSTANCE));
  CMOCK_string_from_gstring_CALL_INSTANCE* cmock_call_instance = (CMOCK_string_from_gstring_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.string_from_gstring_CallInstance = CMock_Guts_MemChain(Mock.string_from_gstring_CallInstance, cmock_guts_index);
  Mock.string_from_gstring_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.string_from_gstring_IgnoreBool = (int)1;
}

void string_from_gstring_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, RIP_MANAGER_INFO* rmi, char* c, int clen, mchar* m, int codeset_type, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_string_from_gstring_CALL_INSTANCE));
  CMOCK_string_from_gstring_CALL_INSTANCE* cmock_call_instance = (CMOCK_string_from_gstring_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.string_from_gstring_CallInstance = CMock_Guts_MemChain(Mock.string_from_gstring_CallInstance, cmock_guts_index);
  Mock.string_from_gstring_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_string_from_gstring(cmock_call_instance, rmi, c, clen, m, codeset_type);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void string_from_gstring_StubWithCallback(CMOCK_string_from_gstring_CALLBACK Callback)
{
  Mock.string_from_gstring_CallbackFunctionPointer = Callback;
}

mchar* mstrdup(mchar* src)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_mstrdup_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrdup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.mstrdup_CallInstance);
  Mock.mstrdup_CallInstance = CMock_Guts_MemNext(Mock.mstrdup_CallInstance);
  if (Mock.mstrdup_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.mstrdup_FinalReturn;
    Mock.mstrdup_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.mstrdup_CallbackFunctionPointer != NULL)
  {
    return Mock.mstrdup_CallbackFunctionPointer(src, Mock.mstrdup_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'mstrdup' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_src), (void*)(src), sizeof(mchar), cmock_line, "Function 'mstrdup' called with unexpected value for argument 'src'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_mstrdup(CMOCK_mstrdup_CALL_INSTANCE* cmock_call_instance, mchar* src)
{
  cmock_call_instance->Expected_src = src;
}

void mstrdup_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, mchar* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrdup_CALL_INSTANCE));
  CMOCK_mstrdup_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrdup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrdup_CallInstance = CMock_Guts_MemChain(Mock.mstrdup_CallInstance, cmock_guts_index);
  Mock.mstrdup_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.mstrdup_IgnoreBool = (int)1;
}

void mstrdup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, mchar* src, mchar* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrdup_CALL_INSTANCE));
  CMOCK_mstrdup_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrdup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrdup_CallInstance = CMock_Guts_MemChain(Mock.mstrdup_CallInstance, cmock_guts_index);
  Mock.mstrdup_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_mstrdup(cmock_call_instance, src);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void mstrdup_StubWithCallback(CMOCK_mstrdup_CALLBACK Callback)
{
  Mock.mstrdup_CallbackFunctionPointer = Callback;
}

mchar* mstrcpy(mchar* dest, const mchar* src)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_mstrcpy_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrcpy_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.mstrcpy_CallInstance);
  Mock.mstrcpy_CallInstance = CMock_Guts_MemNext(Mock.mstrcpy_CallInstance);
  if (Mock.mstrcpy_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.mstrcpy_FinalReturn;
    Mock.mstrcpy_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.mstrcpy_CallbackFunctionPointer != NULL)
  {
    return Mock.mstrcpy_CallbackFunctionPointer(dest, src, Mock.mstrcpy_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'mstrcpy' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_dest), (void*)(dest), sizeof(mchar), cmock_line, "Function 'mstrcpy' called with unexpected value for argument 'dest'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_src), (void*)(src), sizeof(mchar), cmock_line, "Function 'mstrcpy' called with unexpected value for argument 'src'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_mstrcpy(CMOCK_mstrcpy_CALL_INSTANCE* cmock_call_instance, mchar* dest, const mchar* src)
{
  cmock_call_instance->Expected_dest = dest;
  cmock_call_instance->Expected_src = (mchar*)src;
}

void mstrcpy_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, mchar* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrcpy_CALL_INSTANCE));
  CMOCK_mstrcpy_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrcpy_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrcpy_CallInstance = CMock_Guts_MemChain(Mock.mstrcpy_CallInstance, cmock_guts_index);
  Mock.mstrcpy_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.mstrcpy_IgnoreBool = (int)1;
}

void mstrcpy_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, mchar* dest, const mchar* src, mchar* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrcpy_CALL_INSTANCE));
  CMOCK_mstrcpy_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrcpy_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrcpy_CallInstance = CMock_Guts_MemChain(Mock.mstrcpy_CallInstance, cmock_guts_index);
  Mock.mstrcpy_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_mstrcpy(cmock_call_instance, dest, src);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void mstrcpy_StubWithCallback(CMOCK_mstrcpy_CALLBACK Callback)
{
  Mock.mstrcpy_CallbackFunctionPointer = Callback;
}

int msnprintf(mchar* dest, size_t n, const mchar* fmt, ...)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_msnprintf_CALL_INSTANCE* cmock_call_instance = (CMOCK_msnprintf_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.msnprintf_CallInstance);
  Mock.msnprintf_CallInstance = CMock_Guts_MemNext(Mock.msnprintf_CallInstance);
  if (Mock.msnprintf_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.msnprintf_FinalReturn;
    Mock.msnprintf_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.msnprintf_CallbackFunctionPointer != NULL)
  {
    return Mock.msnprintf_CallbackFunctionPointer(dest, n, fmt, Mock.msnprintf_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'msnprintf' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_dest), (void*)(dest), sizeof(mchar), cmock_line, "Function 'msnprintf' called with unexpected value for argument 'dest'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_n), (void*)(&n), sizeof(size_t), cmock_line, "Function 'msnprintf' called with unexpected value for argument 'n'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_fmt), (void*)(fmt), sizeof(mchar), cmock_line, "Function 'msnprintf' called with unexpected value for argument 'fmt'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_msnprintf(CMOCK_msnprintf_CALL_INSTANCE* cmock_call_instance, mchar* dest, size_t n, const mchar* fmt)
{
  cmock_call_instance->Expected_dest = dest;
  memcpy(&cmock_call_instance->Expected_n, &n, sizeof(size_t));
  cmock_call_instance->Expected_fmt = (mchar*)fmt;
}

void msnprintf_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_msnprintf_CALL_INSTANCE));
  CMOCK_msnprintf_CALL_INSTANCE* cmock_call_instance = (CMOCK_msnprintf_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.msnprintf_CallInstance = CMock_Guts_MemChain(Mock.msnprintf_CallInstance, cmock_guts_index);
  Mock.msnprintf_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.msnprintf_IgnoreBool = (int)1;
}

void msnprintf_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, mchar* dest, size_t n, const mchar* fmt, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_msnprintf_CALL_INSTANCE));
  CMOCK_msnprintf_CALL_INSTANCE* cmock_call_instance = (CMOCK_msnprintf_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.msnprintf_CallInstance = CMock_Guts_MemChain(Mock.msnprintf_CallInstance, cmock_guts_index);
  Mock.msnprintf_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_msnprintf(cmock_call_instance, dest, n, fmt);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void msnprintf_StubWithCallback(CMOCK_msnprintf_CALLBACK Callback)
{
  Mock.msnprintf_CallbackFunctionPointer = Callback;
}

void mstrncpy(mchar* dst, mchar* src, int n)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_mstrncpy_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrncpy_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.mstrncpy_CallInstance);
  Mock.mstrncpy_CallInstance = CMock_Guts_MemNext(Mock.mstrncpy_CallInstance);
  if (Mock.mstrncpy_IgnoreBool)
  {
    return;
  }
  if (Mock.mstrncpy_CallbackFunctionPointer != NULL)
  {
    Mock.mstrncpy_CallbackFunctionPointer(dst, src, n, Mock.mstrncpy_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'mstrncpy' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_dst), (void*)(dst), sizeof(mchar), cmock_line, "Function 'mstrncpy' called with unexpected value for argument 'dst'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_src), (void*)(src), sizeof(mchar), cmock_line, "Function 'mstrncpy' called with unexpected value for argument 'src'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_n, n, cmock_line, "Function 'mstrncpy' called with unexpected value for argument 'n'.");
  }
}

void CMockExpectParameters_mstrncpy(CMOCK_mstrncpy_CALL_INSTANCE* cmock_call_instance, mchar* dst, mchar* src, int n)
{
  cmock_call_instance->Expected_dst = dst;
  cmock_call_instance->Expected_src = src;
  cmock_call_instance->Expected_n = n;
}

void mstrncpy_CMockIgnore(void)
{
  Mock.mstrncpy_IgnoreBool = (int)1;
}

void mstrncpy_CMockExpect(UNITY_LINE_TYPE cmock_line, mchar* dst, mchar* src, int n)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrncpy_CALL_INSTANCE));
  CMOCK_mstrncpy_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrncpy_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrncpy_CallInstance = CMock_Guts_MemChain(Mock.mstrncpy_CallInstance, cmock_guts_index);
  Mock.mstrncpy_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_mstrncpy(cmock_call_instance, dst, src, n);
}

void mstrncpy_StubWithCallback(CMOCK_mstrncpy_CALLBACK Callback)
{
  Mock.mstrncpy_CallbackFunctionPointer = Callback;
}

size_t mstrlen(mchar* s)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_mstrlen_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrlen_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.mstrlen_CallInstance);
  Mock.mstrlen_CallInstance = CMock_Guts_MemNext(Mock.mstrlen_CallInstance);
  if (Mock.mstrlen_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.mstrlen_FinalReturn;
    memcpy(&Mock.mstrlen_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(size_t));
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.mstrlen_CallbackFunctionPointer != NULL)
  {
    return Mock.mstrlen_CallbackFunctionPointer(s, Mock.mstrlen_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'mstrlen' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_s), (void*)(s), sizeof(mchar), cmock_line, "Function 'mstrlen' called with unexpected value for argument 's'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_mstrlen(CMOCK_mstrlen_CALL_INSTANCE* cmock_call_instance, mchar* s)
{
  cmock_call_instance->Expected_s = s;
}

void mstrlen_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrlen_CALL_INSTANCE));
  CMOCK_mstrlen_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrlen_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrlen_CallInstance = CMock_Guts_MemChain(Mock.mstrlen_CallInstance, cmock_guts_index);
  Mock.mstrlen_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.mstrlen_IgnoreBool = (int)1;
}

void mstrlen_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, mchar* s, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrlen_CALL_INSTANCE));
  CMOCK_mstrlen_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrlen_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrlen_CallInstance = CMock_Guts_MemChain(Mock.mstrlen_CallInstance, cmock_guts_index);
  Mock.mstrlen_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_mstrlen(cmock_call_instance, s);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(size_t));
}

void mstrlen_StubWithCallback(CMOCK_mstrlen_CALLBACK Callback)
{
  Mock.mstrlen_CallbackFunctionPointer = Callback;
}

mchar* mstrchr(const mchar* ws, mchar wc)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_mstrchr_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrchr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.mstrchr_CallInstance);
  Mock.mstrchr_CallInstance = CMock_Guts_MemNext(Mock.mstrchr_CallInstance);
  if (Mock.mstrchr_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.mstrchr_FinalReturn;
    Mock.mstrchr_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.mstrchr_CallbackFunctionPointer != NULL)
  {
    return Mock.mstrchr_CallbackFunctionPointer(ws, wc, Mock.mstrchr_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'mstrchr' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ws), (void*)(ws), sizeof(mchar), cmock_line, "Function 'mstrchr' called with unexpected value for argument 'ws'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_wc), (void*)(&wc), sizeof(mchar), cmock_line, "Function 'mstrchr' called with unexpected value for argument 'wc'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_mstrchr(CMOCK_mstrchr_CALL_INSTANCE* cmock_call_instance, const mchar* ws, mchar wc)
{
  cmock_call_instance->Expected_ws = (mchar*)ws;
  memcpy(&cmock_call_instance->Expected_wc, &wc, sizeof(mchar));
}

void mstrchr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, mchar* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrchr_CALL_INSTANCE));
  CMOCK_mstrchr_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrchr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrchr_CallInstance = CMock_Guts_MemChain(Mock.mstrchr_CallInstance, cmock_guts_index);
  Mock.mstrchr_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.mstrchr_IgnoreBool = (int)1;
}

void mstrchr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const mchar* ws, mchar wc, mchar* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrchr_CALL_INSTANCE));
  CMOCK_mstrchr_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrchr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrchr_CallInstance = CMock_Guts_MemChain(Mock.mstrchr_CallInstance, cmock_guts_index);
  Mock.mstrchr_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_mstrchr(cmock_call_instance, ws, wc);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void mstrchr_StubWithCallback(CMOCK_mstrchr_CALLBACK Callback)
{
  Mock.mstrchr_CallbackFunctionPointer = Callback;
}

mchar* mstrrchr(const mchar* ws, mchar wc)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_mstrrchr_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrrchr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.mstrrchr_CallInstance);
  Mock.mstrrchr_CallInstance = CMock_Guts_MemNext(Mock.mstrrchr_CallInstance);
  if (Mock.mstrrchr_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.mstrrchr_FinalReturn;
    Mock.mstrrchr_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.mstrrchr_CallbackFunctionPointer != NULL)
  {
    return Mock.mstrrchr_CallbackFunctionPointer(ws, wc, Mock.mstrrchr_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'mstrrchr' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ws), (void*)(ws), sizeof(mchar), cmock_line, "Function 'mstrrchr' called with unexpected value for argument 'ws'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_wc), (void*)(&wc), sizeof(mchar), cmock_line, "Function 'mstrrchr' called with unexpected value for argument 'wc'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_mstrrchr(CMOCK_mstrrchr_CALL_INSTANCE* cmock_call_instance, const mchar* ws, mchar wc)
{
  cmock_call_instance->Expected_ws = (mchar*)ws;
  memcpy(&cmock_call_instance->Expected_wc, &wc, sizeof(mchar));
}

void mstrrchr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, mchar* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrrchr_CALL_INSTANCE));
  CMOCK_mstrrchr_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrrchr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrrchr_CallInstance = CMock_Guts_MemChain(Mock.mstrrchr_CallInstance, cmock_guts_index);
  Mock.mstrrchr_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.mstrrchr_IgnoreBool = (int)1;
}

void mstrrchr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const mchar* ws, mchar wc, mchar* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrrchr_CALL_INSTANCE));
  CMOCK_mstrrchr_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrrchr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrrchr_CallInstance = CMock_Guts_MemChain(Mock.mstrrchr_CallInstance, cmock_guts_index);
  Mock.mstrrchr_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_mstrrchr(cmock_call_instance, ws, wc);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void mstrrchr_StubWithCallback(CMOCK_mstrrchr_CALLBACK Callback)
{
  Mock.mstrrchr_CallbackFunctionPointer = Callback;
}

mchar* mstrncat(mchar* ws1, const mchar* ws2, size_t n)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_mstrncat_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrncat_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.mstrncat_CallInstance);
  Mock.mstrncat_CallInstance = CMock_Guts_MemNext(Mock.mstrncat_CallInstance);
  if (Mock.mstrncat_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.mstrncat_FinalReturn;
    Mock.mstrncat_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.mstrncat_CallbackFunctionPointer != NULL)
  {
    return Mock.mstrncat_CallbackFunctionPointer(ws1, ws2, n, Mock.mstrncat_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'mstrncat' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ws1), (void*)(ws1), sizeof(mchar), cmock_line, "Function 'mstrncat' called with unexpected value for argument 'ws1'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ws2), (void*)(ws2), sizeof(mchar), cmock_line, "Function 'mstrncat' called with unexpected value for argument 'ws2'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_n), (void*)(&n), sizeof(size_t), cmock_line, "Function 'mstrncat' called with unexpected value for argument 'n'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_mstrncat(CMOCK_mstrncat_CALL_INSTANCE* cmock_call_instance, mchar* ws1, const mchar* ws2, size_t n)
{
  cmock_call_instance->Expected_ws1 = ws1;
  cmock_call_instance->Expected_ws2 = (mchar*)ws2;
  memcpy(&cmock_call_instance->Expected_n, &n, sizeof(size_t));
}

void mstrncat_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, mchar* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrncat_CALL_INSTANCE));
  CMOCK_mstrncat_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrncat_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrncat_CallInstance = CMock_Guts_MemChain(Mock.mstrncat_CallInstance, cmock_guts_index);
  Mock.mstrncat_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.mstrncat_IgnoreBool = (int)1;
}

void mstrncat_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, mchar* ws1, const mchar* ws2, size_t n, mchar* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrncat_CALL_INSTANCE));
  CMOCK_mstrncat_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrncat_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrncat_CallInstance = CMock_Guts_MemChain(Mock.mstrncat_CallInstance, cmock_guts_index);
  Mock.mstrncat_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_mstrncat(cmock_call_instance, ws1, ws2, n);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void mstrncat_StubWithCallback(CMOCK_mstrncat_CALLBACK Callback)
{
  Mock.mstrncat_CallbackFunctionPointer = Callback;
}

int mstrcmp(const mchar* ws1, const mchar* ws2)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_mstrcmp_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrcmp_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.mstrcmp_CallInstance);
  Mock.mstrcmp_CallInstance = CMock_Guts_MemNext(Mock.mstrcmp_CallInstance);
  if (Mock.mstrcmp_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.mstrcmp_FinalReturn;
    Mock.mstrcmp_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.mstrcmp_CallbackFunctionPointer != NULL)
  {
    return Mock.mstrcmp_CallbackFunctionPointer(ws1, ws2, Mock.mstrcmp_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'mstrcmp' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ws1), (void*)(ws1), sizeof(mchar), cmock_line, "Function 'mstrcmp' called with unexpected value for argument 'ws1'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ws2), (void*)(ws2), sizeof(mchar), cmock_line, "Function 'mstrcmp' called with unexpected value for argument 'ws2'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_mstrcmp(CMOCK_mstrcmp_CALL_INSTANCE* cmock_call_instance, const mchar* ws1, const mchar* ws2)
{
  cmock_call_instance->Expected_ws1 = (mchar*)ws1;
  cmock_call_instance->Expected_ws2 = (mchar*)ws2;
}

void mstrcmp_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrcmp_CALL_INSTANCE));
  CMOCK_mstrcmp_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrcmp_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrcmp_CallInstance = CMock_Guts_MemChain(Mock.mstrcmp_CallInstance, cmock_guts_index);
  Mock.mstrcmp_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.mstrcmp_IgnoreBool = (int)1;
}

void mstrcmp_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const mchar* ws1, const mchar* ws2, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mstrcmp_CALL_INSTANCE));
  CMOCK_mstrcmp_CALL_INSTANCE* cmock_call_instance = (CMOCK_mstrcmp_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mstrcmp_CallInstance = CMock_Guts_MemChain(Mock.mstrcmp_CallInstance, cmock_guts_index);
  Mock.mstrcmp_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_mstrcmp(cmock_call_instance, ws1, ws2);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void mstrcmp_StubWithCallback(CMOCK_mstrcmp_CALLBACK Callback)
{
  Mock.mstrcmp_CallbackFunctionPointer = Callback;
}

long int mtol(const mchar* string)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_mtol_CALL_INSTANCE* cmock_call_instance = (CMOCK_mtol_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.mtol_CallInstance);
  Mock.mtol_CallInstance = CMock_Guts_MemNext(Mock.mtol_CallInstance);
  if (Mock.mtol_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.mtol_FinalReturn;
    memcpy(&Mock.mtol_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(long int));
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.mtol_CallbackFunctionPointer != NULL)
  {
    return Mock.mtol_CallbackFunctionPointer(string, Mock.mtol_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'mtol' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_string), (void*)(string), sizeof(mchar), cmock_line, "Function 'mtol' called with unexpected value for argument 'string'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_mtol(CMOCK_mtol_CALL_INSTANCE* cmock_call_instance, const mchar* string)
{
  cmock_call_instance->Expected_string = (mchar*)string;
}

void mtol_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, long int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mtol_CALL_INSTANCE));
  CMOCK_mtol_CALL_INSTANCE* cmock_call_instance = (CMOCK_mtol_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mtol_CallInstance = CMock_Guts_MemChain(Mock.mtol_CallInstance, cmock_guts_index);
  Mock.mtol_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.mtol_IgnoreBool = (int)1;
}

void mtol_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const mchar* string, long int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_mtol_CALL_INSTANCE));
  CMOCK_mtol_CALL_INSTANCE* cmock_call_instance = (CMOCK_mtol_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.mtol_CallInstance = CMock_Guts_MemChain(Mock.mtol_CallInstance, cmock_guts_index);
  Mock.mtol_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_mtol(cmock_call_instance, string);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(long int));
}

void mtol_StubWithCallback(CMOCK_mtol_CALLBACK Callback)
{
  Mock.mtol_CallbackFunctionPointer = Callback;
}

int is_id3_unicode(RIP_MANAGER_INFO* mchar_cs)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_is_id3_unicode_CALL_INSTANCE* cmock_call_instance = (CMOCK_is_id3_unicode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.is_id3_unicode_CallInstance);
  Mock.is_id3_unicode_CallInstance = CMock_Guts_MemNext(Mock.is_id3_unicode_CallInstance);
  if (Mock.is_id3_unicode_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.is_id3_unicode_FinalReturn;
    Mock.is_id3_unicode_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.is_id3_unicode_CallbackFunctionPointer != NULL)
  {
    return Mock.is_id3_unicode_CallbackFunctionPointer(mchar_cs, Mock.is_id3_unicode_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'is_id3_unicode' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_mchar_cs), (void*)(mchar_cs), sizeof(RIP_MANAGER_INFO), cmock_line, "Function 'is_id3_unicode' called with unexpected value for argument 'mchar_cs'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_is_id3_unicode(CMOCK_is_id3_unicode_CALL_INSTANCE* cmock_call_instance, RIP_MANAGER_INFO* mchar_cs)
{
  cmock_call_instance->Expected_mchar_cs = mchar_cs;
}

void is_id3_unicode_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_is_id3_unicode_CALL_INSTANCE));
  CMOCK_is_id3_unicode_CALL_INSTANCE* cmock_call_instance = (CMOCK_is_id3_unicode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.is_id3_unicode_CallInstance = CMock_Guts_MemChain(Mock.is_id3_unicode_CallInstance, cmock_guts_index);
  Mock.is_id3_unicode_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.is_id3_unicode_IgnoreBool = (int)1;
}

void is_id3_unicode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, RIP_MANAGER_INFO* mchar_cs, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_is_id3_unicode_CALL_INSTANCE));
  CMOCK_is_id3_unicode_CALL_INSTANCE* cmock_call_instance = (CMOCK_is_id3_unicode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.is_id3_unicode_CallInstance = CMock_Guts_MemChain(Mock.is_id3_unicode_CallInstance, cmock_guts_index);
  Mock.is_id3_unicode_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_is_id3_unicode(cmock_call_instance, mchar_cs);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void is_id3_unicode_StubWithCallback(CMOCK_is_id3_unicode_CALLBACK Callback)
{
  Mock.is_id3_unicode_CallbackFunctionPointer = Callback;
}

gchar* utf8_string_from_string(char* src, char* codeset)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_utf8_string_from_string_CALL_INSTANCE* cmock_call_instance = (CMOCK_utf8_string_from_string_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.utf8_string_from_string_CallInstance);
  Mock.utf8_string_from_string_CallInstance = CMock_Guts_MemNext(Mock.utf8_string_from_string_CallInstance);
  if (Mock.utf8_string_from_string_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.utf8_string_from_string_FinalReturn;
    Mock.utf8_string_from_string_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.utf8_string_from_string_CallbackFunctionPointer != NULL)
  {
    return Mock.utf8_string_from_string_CallbackFunctionPointer(src, codeset, Mock.utf8_string_from_string_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'utf8_string_from_string' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_src, src, cmock_line, "Function 'utf8_string_from_string' called with unexpected value for argument 'src'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_codeset, codeset, cmock_line, "Function 'utf8_string_from_string' called with unexpected value for argument 'codeset'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_utf8_string_from_string(CMOCK_utf8_string_from_string_CALL_INSTANCE* cmock_call_instance, char* src, char* codeset)
{
  cmock_call_instance->Expected_src = src;
  cmock_call_instance->Expected_codeset = codeset;
}

void utf8_string_from_string_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, gchar* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_utf8_string_from_string_CALL_INSTANCE));
  CMOCK_utf8_string_from_string_CALL_INSTANCE* cmock_call_instance = (CMOCK_utf8_string_from_string_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.utf8_string_from_string_CallInstance = CMock_Guts_MemChain(Mock.utf8_string_from_string_CallInstance, cmock_guts_index);
  Mock.utf8_string_from_string_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.utf8_string_from_string_IgnoreBool = (int)1;
}

void utf8_string_from_string_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* src, char* codeset, gchar* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_utf8_string_from_string_CALL_INSTANCE));
  CMOCK_utf8_string_from_string_CALL_INSTANCE* cmock_call_instance = (CMOCK_utf8_string_from_string_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.utf8_string_from_string_CallInstance = CMock_Guts_MemChain(Mock.utf8_string_from_string_CallInstance, cmock_guts_index);
  Mock.utf8_string_from_string_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_utf8_string_from_string(cmock_call_instance, src, codeset);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void utf8_string_from_string_StubWithCallback(CMOCK_utf8_string_from_string_CALLBACK Callback)
{
  Mock.utf8_string_from_string_CallbackFunctionPointer = Callback;
}

